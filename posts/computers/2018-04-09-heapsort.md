---
title: heapsort
date: 2018-04-09
---


# Heapsort

In the [last post](2018-04-01-insertion-and-merge-sort.html) we implemented the insertion and merge sort algorithms. Insertion sort has time complexity $O(L^2)$ and space complexity $O(1)$. Merge sort has time complexity $O(L \log L)$ and space complexity $O(L)$. It is natural to ask if there is an array sorting algorithm with time complexity $O(L \log L)$ and space complexity $O(1)$. The heapsort algorithm has these properties, and we shall implement it in this post. All this code and some testing code can be [found](../../CALGO/max_binary_heap/max_binary_heap.c) [here](../../CALGO/max_binary_heap/test.c).

### Max Binary Heaps

We can encode a complete binary tree using an array as follows:
<img src="/img/binary_heap_storage.svg" style="width: 800px; display: block; margin: 0 auto;"/>
If $i$ is an index, then the parent index is $\left \lfloor i/2 \right \rfloor$, the left child index is $2i$ and the right child index is $2i+1$. This is the fundamental idea behind the max binary heap data structure which we implement as follows:
```{.c}
typedef struct
{
  /* array of pointers */
  void **array;

  /* length of array */
  int length;

  /*
    length of heap. Not all elements in the array are part of the heap.
    The array is array[1..length].
    The heap is array[1..heap_size].
    When heap_size < length, then array[heap_size + 1..length] is extra space.
   */
  int heap_size;

  /*
    compare points to a procedure which computes *ptr1 < *ptr2
   */
  int (*compare)(void *ptr1, void *ptr2);


} heap;
```
The data structure consists of an array $A$ of objects, its length $L$, the length of the heap $H$ and a procedure for comparing objects in the array. Not every element in the array is part of the heap. The heap consists of the entries $A[1..H]$ and the entries $A[H+1..L]$ are extra space.
